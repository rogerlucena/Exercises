
--- Some of my notes, useful links and observations ---

-- To compile (command line)
g++ -std=c++17 main.cpp -o main; ./main

-- Tree traversals (Inorder, Preorder and Posorder)
http://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/

E.g.: Inorder:
1) left child
2) this.data
3) right child
(The other traversals just change the position of this.data)

Obs: Preorder to copy the tree (polish_notation too), Posorder to delete, Inorder to get int numbers in ascending order from a BST

- Notation for titles inside ./Problems folder:
"__" stands for good problems with interesting / key ideas to remember
"_" stands for more interesting / difficult problems, compared to the usual (but not necessarily with key ideas to remember)

- Construct Tree from given Inorder and Preorder traversals:
http://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/

- Construct a Binary Search Tree from given postorder
http://www.geeksforgeeks.org/construct-a-binary-search-tree-from-given-postorder/

-- STL Containers Complexities:
https://www.cs.northwestern.edu/~riesbeck/programming/c++/stl-summary.html


-- Sorting:

- Stable means that i < j, A[i] == A[j], than pi(i) < pi(j), where "pi" is the map for the new positions (after sorting).
- Merge sort is stable, quick and heap are not:
https://www.geeksforgeeks.org/stability-in-sorting-algorithms/

- Quick Sort (chache friendly, not stable, in place, worst case is O(n²), but avoided if we choose a good pivot (near the median) - random):
https://www.geeksforgeeks.org/quick-sort/

- Merge Sort (stable, additional O(n) in space but better for big data in different databases. For linked lists, where insertion is O(1), no need of additional space):
https://www.geeksforgeeks.org/merge-sort/

- Counting Sort (auxiliar array - 0 to 100 ages, O(n) time) and Radix Sort (O(kn) where k = log(max_el))
They are better exaplined on the Cracking the Coding Interview

-- Interesting way of calculating binomial coeffs:
https://www.geeksforgeeks.org/binomial-coefficient-dp-9/

-- Complexity:
n < nlog(n)
n^x < n^y if x < y
n^x < c^n where c is a constant (polynomials will eventually grow slower than exponentials)
log(n) < n
c^n < n! < n^n where c is a constant

-- For complexity with recursions, see "Master method":
https://www.geeksforgeeks.org/analysis-algorithm-set-4-master-method-solving-recurrences/

-- Quick-Sort with Tail-Recursive Optimization (TRO or TCO)
http://mypathtothe4.blogspot.com/2013/02/lesson-2-variations-on-quicksort-tail.html ("How this works is that instead of 'rigid' branches as in the original Quicksort, the new branches can swing into different positions to cover every path")
Support: https://www.geeksforgeeks.org/quicksort-tail-call-optimization-reducing-worst-case-space-log-n/ 
(for this last link: taking the side with less elements first we guarantee it has maximun n/2 elements, then the recursion tree has a maximun logn in height - additional space in the stack =D)

-- Two pointers idea (very common, tricks):
Start with the brute force and then analyze if you can optimize it - discard some iterations that will not improve the result
https://www.interviewbit.com/tutorial/two-pointers/

-- Topological Sorting (or Ordering) for DAGs:
- Using "inDegree" array and a queue "q" - add vertex to "q" only if its current inDegree is zero (never happens for 
vertices in a cycle): https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/
(if "visitedCount != V" we have cycle - question at VTEX and "__course_schedule" problem)
- Using DFS and a stack (add vertex to it only after going through all the neighbors) - only to find the TO 
if you already know it is a DAG: https://www.geeksforgeeks.org/topological-sorting/ 

-- Trees (attention here):
Depth: distance (#edges) from root (d(root) = 0)
Height: largest distance (#edges) to a leaf (h(every leaf) = 0)
Height of the tree: h(root)

-- Idea to prove Greedy:
https://www.interviewbit.com/tutorial/activity-selection-problem/
If other ("k") than the greedy choice ("1") was taken, show that "(S - {k}) U {1}" would also be a solution 
(remember the example of choosing tasks, take the ones with smaller finish time first)
(or the _assign_mice_to_holes problem - sort both and remember: max(|i1 - j1|, |i2 - j2|) <= max(|i1 - j2|, |i2 - j1|))

-- Dynamic Programming
1) Try to divide into smaller recursive problems, if overlaps -> memoization
2) See space and time, try to optmize

-- Difference between Delete and Free:
Delete is an operator while Free is a function. Delete frees the allocated memory and also calls 
the destructor of the class in c++ while free() does not calls any destructor and only free the allocated 
memory set with malloc in C. Free() uses C run time heap whereas Delete may be overloaded on class basis to use private heap.
Syntax: delete ptr; free(ptr);

-- Graph representations:
Adjacency Matrix: 
    Pros: O(1) to see if an edge
    Cons: Consumes O(V^2) space (even if sparse), O(V^2) to add a new vertex too (if you have to copy everything into a new matrix; in this case, think about amortized to improve time efficiency)
Asjacency list:
    Pros: O(V+E) in space, adding a vertex is easier; space worst case: C(V, 2) edges in a graph thus consuming O(V^2) space
    Cons: To verify if an edge, O(V) in the worst case

### impt ###

-- Dicas Carolzinha e outras (top 3 coisas pra estudar)
- Linked Lists (70% das questões dela)
- Percurso em grafo, DFS/BFS (dijkstra, minimum path, red-black & AVL trees - não necessário)
- Recursão, DP

- coisas implementação by heart: inverter uma linked list (https://www.geeksforgeeks.org/reverse-a-linked-list/), 
         binary search, merge two sorted linked lists (in remember_liked_lists.cpp), não pembe em DFS/BFS! (code imediato!),
         quick sort (?), rever outros sorts tb (merge, insertion, bubble, radix, bucket, counting ...)
- revisa bem: hash_map (cai muito!), queues, stacks (problema dos parênteses, ver "merge_overlapping_intervals.cpp" também)
- knapsack problem, traveling salesman, "coin_exchange.cpp", "get_subsets.cpp" - DP


-- Lembrar, passo a passo:
1) Faz um exemplo simples pra ver se realmente entendeu, se necessário
    Ask clarification questions to see if you really got what they want (float numbers? sorted? 
    repeated numbers? negative? can I get two of the same index? Any time/space requirements?
    se nao tem resposta, o que retorno nesse caso? (eg: era empty no caso de {1} no pb do produto dos outros),
    vetor ordenado? lowercase?)
2) Always think out loud! 
    se precisar de 1 min em silêncio, PEçA! Comunique isso!
    problema aberto? pede a API, pensa no caso mais simple possível (squared room with discret cells), se 
    errado ele te corrige
3) Brute-force and complexities (importante falar logo o brute-force logo! - nada bom se ele achar que nem o brute vc sabe) 
    then optimze! (no coding yet!)
    SE VC estah pensando em uma estrategia, mas viu um possivel problema, FALE, ele pode te dizer como
    resolver (eg: heaps tamanhos mto diferents no pb da median de um stream), ou que nem eh possivel ter esse problema
4) Should I optimize more or can I code? Think out loud while coding!
    Tudo eh ok, desde que vc fale. “Normalmente essa var deveria ter nome tal .. mas for the sake of time/simplicity, let’s use ..”
    funcão auxiliar que as vezes nem precisa codar no final! 
5) Test it line by line (do not skip lines)! Colocando valores das variáveis ao lado como comentário
    Comeca com os mais simples (empty, {1}, corner cases, then small ones - 2/3 els, já é enough pra achar bugs)! 2x2 ja dá (robot)
6) No final: projeto favorito? parte mais desafiadora lá? melhor parte comparado com as outras antes?
             qual o bug mais interessante em que você já se encontrou? procedimento para deploy em prod?

- Red flags: base case recursion, lembre usar a condition tb otherwise infinite loop! 
    Nao inicializar alguma variavel, DFS, BFS, update step for not infinity loop inside while
- Invariants … boa palavra, gostam quando usamos (e.g.: you have to phisically bring the robot back) 

here -> remember_by_heart.cpp -> files with __