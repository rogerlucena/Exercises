
--- Some of my notes, useful links and observations ---

-- To compile (command line)
g++ -std=c++17 main.cpp -o main; ./main

-- Tree traversals (Inorder, Preorder and Posorder)
http://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/

E.g.: Inorder:
1) left child
2) this.data
3) right child
(The other traversals just change the position of this.data)

Obs: Preorder to copy the tree (polish_notation too), Posorder to delete, Inorder to get int numbers in ascending order from a BST

- Notation for titles inside ./Problems folder:
"__" stands for good problems with interesting / key ideas to remember
"_" stands for more interesting / difficult problems, compared to the usual (but not necessarily with key ideas to remember)

- Construct Tree from given Inorder and Preorder traversals:
http://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/

- Construct a Binary Search Tree from given postorder
http://www.geeksforgeeks.org/construct-a-binary-search-tree-from-given-postorder/

-- STL Containers Complexities:
https://www.cs.northwestern.edu/~riesbeck/programming/c++/stl-summary.html


-- Sorting:

- Stable means that i < j, A[i] == A[j], than pi(i) < pi(j), where "pi" is the map for the new positions (after sorting).
- Merge sort is stable, quick and heap are not:
https://www.geeksforgeeks.org/stability-in-sorting-algorithms/

- Quick Sort (chache friendly, not stable, in place, worst case is O(n²), but avoided if we choose a good pivot (near the median) - random):
https://www.geeksforgeeks.org/quick-sort/

- Merge Sort (stable, additional O(n) in space but better for big data in different databases. For linked lists, where insertion is O(1), no need of additional space):
https://www.geeksforgeeks.org/merge-sort/

- Counting Sort (auxiliar array - 0 to 100 ages, O(n) time) and Radix Sort (O(kn) where k = log(max_el))
They are better exaplined on the Cracking the Coding Interview

-- Interesting way of calculating binomial coeffs:
https://www.geeksforgeeks.org/binomial-coefficient-dp-9/

-- Complexity:
n < nlog(n)
n^x < n^y if x < y
n^x < c^n where c is a constant (polynomials will eventually grow slower than exponentials)
log(n) < n
c^n < n! < n^n where c is a constant

-- For complexity with recursions, see "Master method":
https://www.geeksforgeeks.org/analysis-algorithm-set-4-master-method-solving-recurrences/

-- Quick-Sort with Tail-Recursive Optimization (TRO or TCO)
http://mypathtothe4.blogspot.com/2013/02/lesson-2-variations-on-quicksort-tail.html ("How this works is that instead of 'rigid' branches as in the original Quicksort, the new branches can swing into different positions to cover every path")
Support: https://www.geeksforgeeks.org/quicksort-tail-call-optimization-reducing-worst-case-space-log-n/ 
(for this last link: taking the side with less elements first we guarantee it has maximun n/2 elements, then the recursion tree has a maximun logn in height - additional space in the stack =D)

-- Two pointers idea (very common, tricks):
Start with the brute force and then analyze if you can optimize it - discard some iterations that will not improve the result
https://www.interviewbit.com/tutorial/two-pointers/

-- Topological Sorting (or Ordering) for DAGs:
- Using "inDegree" array and a queue "q" - add vertex to "q" only if its current inDegree is zero (never happens for 
vertices in a cycle): https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/
(if "visitedCount != V" we have cycle - question at VTEX and "__course_schedule" problem)
- Using DFS and a stack (add vertex to it only after going through all the neighbors) - only to find the TO 
if you already know it is a DAG: https://www.geeksforgeeks.org/topological-sorting/ 

-- Trees (attention here):
Depth: distance (#edges) from root (d(root) = 0)
Height: largest distance (#edges) to a leaf (h(every leaf) = 0)
Height of the tree: h(root)

-- Idea to prove Greedy:
https://www.interviewbit.com/tutorial/activity-selection-problem/
If other ("k") than the greedy choice ("1") was taken, show that "(S - {k}) U {1}" would also be a solution 
(remember the example of choosing tasks, take the ones with smaller finish time first)
(or the _assign_mice_to_holes problem - sort both and remember: max(|i1 - j1|, |i2 - j2|) <= max(|i1 - j2|, |i2 - j1|))

-- Dynamic Programming
1) Try to divide into smaller recursive problems, if overlaps -> memoization
2) See space and time, try to optmize

-- Difference between Delete and Free:
Delete is an operator while Free is a function. Delete frees the allocated memory and also calls 
the destructor of the class in c++ while free() does not calls any destructor and only free the allocated 
memory set with malloc in C. Free() uses C run time heap whereas Delete may be overloaded on class basis to use private heap.
Syntax: delete ptr; free(ptr);

-- When interviewing, remember step by step:
1) Ask clarification questions to see if you really got what they want (float numbers? sorted? repeated numbers? negative? can I get two of the same index?)
2) Always think out loud! (any time/space requirements?)
3) Brute-force and complexities, then optimze! (no coding yet!)
4) Code, think out loud while doing it!
5) Test it line by line (do not skip lines)! See edge cases (if empty, only one element ...)!

-- Dicas Carolzinha e outras (top 3 coisas pra estudar)
- Linked Lists (70% das questões dela)
- Percurso em grafo, DFS/BFS (dijkstra, minimum path, red-black & AVL trees - não necessário)
- Recursão, DP

- coisas implementação by heart: inverter uma linked list (https://www.geeksforgeeks.org/reverse-a-linked-list/), 
         binary search, merge two sorted linked lists (in remember_liked_lists.cpp),
         quick sort (?), rever outros sorts tb (merge, insertion, bubble, radix, bucket, counting ...)
- revisa bem: hash_map (cai muito!), queues, stacks (problema dos parênteses, ver "merge_overlapping_intervals.cpp" também)
- knapsack problem, traveling salesman, "coin_exchange.cpp", "get_subsets.cpp" - DP
- perguntas: projeto favorito? parte mais desafiadora lá? melhor parte comparado com as outras antes?