
--- Some of my notes, useful links and observations ---

-- To compile (command line)
g++ -std=c++17 main.cpp -o main ; ./main

-- Tree traversals (Inorder, Preorder and Posorder)
http://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/

E.g.: Inorder:
1) left child
2) this.data
3) right child
(The other traversals just change the position of this.data)

Obs: Preorder to copy the tree (polish_notation too), Posorder to delete, Inorder to get int numbers in ascending order from a BST

- Construct Tree from given Inorder and Preorder traversals:
http://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/

- Construct a Binary Search Tree from given postorder
http://www.geeksforgeeks.org/construct-a-binary-search-tree-from-given-postorder/


-- STL Containers Complexities:
https://www.cs.northwestern.edu/~riesbeck/programming/c++/stl-summary.html


-- Sorting:

- Stable means that i < j, A[i] == A[j], than pi(i) < pi(j), where "pi" is the map for the new positions (after sorting).
- Merge sort is stable, quick and heap are not:
https://www.geeksforgeeks.org/stability-in-sorting-algorithms/

- Quick Sort (chache friendly, not stable, in place, worst case is O(n²), but avoided if we choose a good pivot (near the median) - random):
https://www.geeksforgeeks.org/quick-sort/

- Merge Sort (stable, additional O(n) in space but better for big data in different databases. For linked lists, where insertion is O(1), no need of additional space):
https://www.geeksforgeeks.org/merge-sort/

- Counting Sort (auxiliar array - 0 to 100 ages, O(n) time) and Radix Sort (O(kn) where k = log(max_el))
They are better exaplined on the Cracking the Coding Interview


-- Complexity:
n < nlog(n)
n^x < n^y if x < y
n^x < c^n where c is a constant (polynomials will eventually grow slower than exponentials)
log(n) < n
c^n < n! < n^n where c is a constant

-- For complexity with recursions, see "Master method":
https://www.geeksforgeeks.org/analysis-algorithm-set-4-master-method-solving-recurrences/

-- Quick-Sort with Tail-Recursive Optimization (TRO or TCO)
http://mypathtothe4.blogspot.com/2013/02/lesson-2-variations-on-quicksort-tail.html ("How this works is that instead of 'rigid' branches as in the original Quicksort, the new branches can swing into different positions to cover every path")
Support: https://www.geeksforgeeks.org/quicksort-tail-call-optimization-reducing-worst-case-space-log-n/ 
(for this last link: taking the side with less elements first we guarantee it has maximun n/2 elements, then the recursion tree has a maximun logn in height - additional space in the stack =D)

-- Topological Sorting for DAGs:
to verify if it is a DAG (question at VTEX): https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/
given it is a DAG: https://www.geeksforgeeks.org/topological-sorting/ 

-- Dicas Carolzinha e outras (top 3 coisas pra estudar)
- Linked Lists (705 das questões dela, faz 3 do leetcode)
- Percurso em grafo, DFS/BFS (dijkstra, minimum path, red-black & AVL trees - não necessário)
- Recursão, DP

- coisas implementação by heart: binary search, inverter uma linked list, quick sort (?), rever outros sorts tb (merge, insertion, bubble, radix, bucket, counting ...)
- revisa bem: hash_map (cai muito!), queues, stacks (problema dos parênteses, ver "merge_overlapping_intervals.cpp" também)
- knapsack problem, traveling salesman, "coin_exchange.cpp", "get_subsets.cpp" - DP
- perguntas: projeto favorito? parte mais desafiadora lá? melhor parte comparado com as outras antes?